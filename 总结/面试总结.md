# 学习策略

![](./pic/学习策略.png)

## Java工程师精选面经集合

![](./pic/Java工程师精选面经集合.png)

超链接地址： https://www.nowcoder.com/discuss/experience?tagId=639

面试宝典导读： https://www.nowcoder.com/tutorial/94/ea1986fcff294f6292385703e94689e8

# Java基础

## 1-基础

**1 、数据类型**

基本数据类型（八大）

**整型: byte（1字节:-128~127）、short（2字节）、int（4字节）、long(L)（8字节）**

**浮点型：float(F)（4字节）、double（8字节）**

**字符型: char（2字节）**

**布尔型: boolean（占1位）**

1Byte = 8bit

1KB = 1024B

1MB = 1024KB

1GB = 1024MB



引用数据类型:

**数组**

**类型**

**类（String类）**

![](./pic/数据类型容量.png)

**2、数据类型扩展**

整数扩展：二进制0b、十进制、八进制0、十六进制0x

浮点数扩展：BigDecimal类

char unicode 数字-字符   48-0  65-A  97-a    即: char c = '\u0061'



数据类型转换： **低到高 -> 自动类型提升**   **高到低 -> 强制类型转换** 



**3、变量和常量**

public class demo {

​		static int num; // 类变量  demo.num

​		int num;  // 成员变量  new demo().num

​		public void method() {

​        		int num; // 局部变量

​		}

}



常量一般大写，且用final修饰

final double PI =3.14



**变量的命名规范：**

①类成员变量和局部变量：首字母小写+驼峰原则 lastName

②常量：大写字母+下划线  MAX_VALUE

③类名：首字母大写+驼峰原则 Main

④方法名：首字母小写+驼峰原则 runRun()



**4、运算符**

①算术运算符：+，-，*，/，%，++，--

②赋值运算符：=

③关系运算符：>，<，>=，<=，==，!= ，instanceof

④逻辑运算符：&&，||，！（**短路运算**）

⑤位运算符：&（与），|（或），^（异或），~（非），>>（ 相当于/2），<<（相当于*2），>>>

\>>：带符号右移。正数右移高位补0，负数右移高位补1

\>>>：无符号右移。无论是正数还是负数，高位通通补0

⑥条件运算符：？:

⑦扩展赋值运算符：+=，-=，*=，、=

注意: +有时候表示字符串的拼接，a=10,b=20,  则""+a+b ->  1020 ， 而a+b+"" -> 30



**5、包机制**

![](./pic/包机制.png)



**6、JavaDoc**

@author作者名		@version版本号		@since指明最早使用的jdk版本

@param参数名		@return返回值情况		@throws异常抛出情况

生存JavaDoc的命令：javadoc -encoding UTF-8 -charset UTF-8 test.java



7、Scanner类输入

```java
Scanner sc = new Scanner(System.in);
if (sc.hasNext()) {
	String str = sc.next();
}
```

![](.\pic\next和nextline.png)

**8、关于流程控制的补充**

```java
switch(expression) {
    case A:
        语句;
       	break;
    default:
        语句;
}
```



switch语句中的变量类型: byte 、short、int、char

JavaSE7 中 switch支持字符串String类型，case必须位字符串常量或字面量



循环中的九九乘法表

![](.\pic\九九乘法表.png)

**9、方法的重载**

重载：在一个类中有相同的函数名称，但是形参不同的函数

规则：方法名相同，参数列表不同（个数，类型，参数排列顺序），但是返回类型不同不足以成为方法的重载。



可变参数： void test(int...i) 必须是参数的最后一个



**10、内存分析**

![image-20220221205808806](.\pic\内存分析.png)

**11、数组的三种初始化：**

①静态初始化： int[] arr = {1, 2, 3};

②动态初始化：int[] arr = new int[3]; a[0] = 1

③数组默认初始化：数组是引用类型



Arrays工具类：

fill(nums, x)方法：nums数组填充x

toString()方法：打印数据元素

sort（）方法：数组排序

equals（）方法：比较数组中的元素值是否相等

查找数组元素：通过binarySearch（）方法堆排序好的数组进行二分查找



**12、值传递和引用传递**（实际是传递地址）

值传递：基础类型

引用传递：类、接口、数组



**13、构造器**

和类名相同，没有返回值 

new的本质是在调用构造器

定义了有参构造，如果使用无参构造，必须显示写出有参构造



**14、封装、继承、多态**

① 关于封装

高内聚，低耦合

属性私有private，通过get/set获取或设置

隐藏代码的实现细节，保证数据的安全性



② 关于继承

is a的关系

```java
public void test(String name) {
    System.out.println(name);
    System.out.println(this.name);
    System.out.println(super.name);
} 
```

super调用父类的构造方法，必须在构造方法中的第一个

super必须只能出现在子类的方法或构造方法中

super和this不能同时调用构造方法



super和this的区别

代表对象不同：

​		super表示父类对象的引用

​		this表示本身对象的调用

前提：

​		this 没有继承也可以使用

​		super 只能在继承条件中才可以使用

构造方法：

​		this（）本类的构造

​		super（）父类的构造



③ 关于多态

多态：父类的引用指向子类对象（方法的多态，不是属性的多态）

静态方法：方法的调用只和左边所定义的数据类型有关（类加载就出现）

非静态方法：先继承后重写 。编译看左（只能调用左边存在的方法），运行看右（有重写，执行重写的方法）



A extends B

A a = new A();

B a = new A(); // 多态

注意问题：

**1 父类可以指向子类，但是不能调用子类的方法**

**2 子类可以调用自己或者父类的方法**

**3 static 方法属于类，不属于实例， final 不能被修改， private方法**

④ 重写

注意点：

1 子类继承父类，子类重写父类方法，而且必须是方法名字相同,方法体不同

2 参数列表相同

3 修饰符和范围可以扩大： private -> public

4 抛出的异常范围可以缩小： Exception -> ClassNotFoundException



**15、instanceof方法**

判断一个对象是什么类型

instanceof （类型转换）



**16、关于代码的加载先后顺序**

```java
public class Demo {
    static {
        1 静态代码块（只执行一次）
    }
    {
        2 匿名代码块
    }
    public Demo() {
        3 构造方法代码块
    }
}
```

**17、抽象类和接口**

类单继承，接口可以多继承

抽象类：

1、子类继承，然后重写实现

2 、抽象类中可以写普通的方法，但是抽象方法必须在抽象类中



| 普通类 | 只有具体实现                                                 |
| ------ | ------------------------------------------------------------ |
| 抽象类 | 有具体实现和抽象方法                                         |
| 接口   | 只有抽象方法（属性是public static final和方法是public abstract） |

面向接口编程：约束和实现分离（能不能的问题）

**18、内部类**

① 成员内部类

```java
public class Outer {
    private int id = 10;
    public void out() {}
    
    public class Inner {
        public viod in() {}
        
        public void getID() {
            
        }
    }
}

psvm {
    Outer.Inner inner = new  Outer().new Inner();
}
```



② 局部内部类（方法内部定义）

```java
public class Outer {
    private int id = 10;
    public void out() {
        class Inner() {
            
        }
    }
}
```



③ 静态内部类

```java
public class Outer {
    private int id = 10;
    public void out() {}
    
    public static class Inner {
        public viod in() {}
        
        public void getID() {
            
        }
    }
}
```



④ 匿名内部类

**接口的匿名实现类的匿名对象**

**抽象类的匿名子类的匿名对象**

new Fly() {

​	@Override

​	public void test() {}

};

**19、异常类（异常Exception和错误Error  ）**

Error通常是虚拟机抛出的异常，一般程序是无法控制和处理的，Exception一般是程序可以处理的异常



处理：try、catch、finally、throw、throws

catch（想要捕获的类型）

finally （释放资源）

throw new Exception(); （主动抛出异常，一般在方法中使用）

throws (如果方法不能处理异常，那么在方法上使用)

## 2-容器

## 3-并发编程

## 4-JVM

## 5-新特性

## 6-小技巧

## 7-JavaWeb

1 基本概念 

1.1 静态web和动态web

- 静态web： 提供给所有人的数据始终不变
- 动态web：会动态变化，技术栈使用servlet/jsp

1.2 web应用程序

- 可以供浏览器访问的程序

- 统一的web资源会放在同一个文件夹下，web应用程序 -> tomcat 服务器

- 包含：html/css/js、jsp/servlet、java程序、jar包、配置文件（properties）

  ![image-20220222223753082](面试总结.assets/image-20220222223753082.png)

## 8-Spring

## 9-SpringMVC

## 10-Mybatis

## 11-SpringBoot



# 计算机基础

## 1-计算机网络

### 概述

**网络的网络**

网络把主机连接起来，互联网把多种不同的网络连接起来，即互联网是网络的网络。

**ISP**

*Internet Service Provider*，互联网服务提供商，ISP分为第一层ISP,区域ISP和接入ISP。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72be01cd-41ae-45f7-99b9-a8d284e44dd4.png)

**主机之间的通信方式**

客户-服务器（C/S）:客户是服务的请求方，服务器是服务的提供方

对等（P2P）：不区分客户和服务器

**电路交换与分组交换**

电路交换：电路交换用于电话通信系统，两个用户通信前先建立一条专用的物理链路，并且在整个通信过程中始终占有该链路，但是电路交换对线路的利用率很低。

分组交换：每个分组都含有首部和尾部，包含源地址和目的地址，在同一传输线路中可以同时传输多个分组

**（分组交换+存储转发）**

**时延**

总时延 = 传输时延 + 传播时延 + 排队时延 + 处理时延

① 排队时延

分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。

② 处理时延

主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。

③ 传输时延

主机或路由器传输数据帧所需要的时间。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dcdbb96c-9077-4121-aeb8-743e54ac02a4.png)



其中 l 表示数据帧的长度，v 表示传输速率。

④传播时延

电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a1616dac-0e12-40b2-827d-9e3f7f0b940d.png)



其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg)

**计算机网络体系结构**

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png)

**① OSI七层模型**：

表示层：数据压缩、加密和数据描述，使得应用程序不必关系再各台主机中数据格式不同的问题。

会话层：建立以及管理会话。

**② 五层协议：**

应用层：为特定的程序提供数据传输服务，如HTTP、DNS等协议。**数据单位是报文。**

运输层：为进程提供数据传输服务（面向端口）。

TCP（传输控制协议），**数据单位是报文段**，面向有连接，可靠的数据传输服务，主要提供完整性服务；

UDP（用户数据报协议），**数据单位是用户数据报**，面向无连接，尽最大努力的数据传输服务，主要提供及时性服务。

网络层：为主机提供数据传输服务。但是传输层的协议是为主机中的进程提供数据传输服务。网络层把传输层的报文段或者用户数据报封装成分组。**数据单位是分组**，分组交换和存储转发。

数据链路层：主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。**数据单位是帧。**

物理层：如何再传输媒介上透明地传输比特流。**数据单位是比特流。**

**③ TCP/IP：**应用层、运输层、网际层、网络接口层

相当于五层协议中的数据链路层和物理层合并成为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png)

**④ 数据在各层之间的传输过程：**

向下过程中，需要添加下层协议所需要的首部或者尾部，向上的过程中，需要拆开首部和尾部。



路由器只有下三层协议，网络层，数据链路层和物理层，不需要为进程或者应用程序提供服务，所以不需要传输层和应用层。



### 物理层

### 链路层

### 网络层

### 传输层

### 应用层



## 2-操作系统



## 3-数据结构



## 4-算法



# 数据库



# 系统结构



# 分布式



# 高性能



# 高可用



# 简历模板

![image-20211217211039759](C:\Users\tesseract\AppData\Roaming\Typora\typora-user-images\image-20211217211039759.png)

