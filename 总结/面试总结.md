# 学习策略

![](./面试总结.assets/学习策略.png)

## Java工程师精选面经集合

![](./面试总结.assets/Java工程师精选面经集合.png)

超链接地址： https://www.nowcoder.com/discuss/experience?tagId=639

面试宝典导读： https://www.nowcoder.com/tutorial/94/ea1986fcff294f6292385703e94689e8

# Java基础

## 1-基础

**1 、数据类型**

基本数据类型（八大）

**整型: byte（1字节:-128~127）、short（2字节）、int（4字节）、long(L)（8字节）**

**浮点型：float(F)（4字节）、double（8字节）**

**字符型: char（2字节）**

**布尔型: boolean（占1位）**

1Byte = 8bit

1KB = 1024B

1MB = 1024KB

1GB = 1024MB



引用数据类型:

**数组**

**类型**

**类（String类）**

![](./面试总结.assets/数据类型容量.png)

**2、数据类型扩展**

整数扩展：二进制0b、十进制、八进制0、十六进制0x

浮点数扩展：BigDecimal类

char unicode 数字-字符   48-0  65-A  97-a    即: char c = '\u0061'



数据类型转换： **低到高 -> 自动类型提升**   **高到低 -> 强制类型转换** 



**3、变量和常量**

public class demo {

​		static int num; // 类变量  demo.num

​		int num;  // 成员变量  new demo().num

​		public void method() {

​        		int num; // 局部变量

​		}

}



常量一般大写，且用final修饰

final double PI =3.14



**变量的命名规范：**

①类成员变量和局部变量：首字母小写+驼峰原则 lastName

②常量：大写字母+下划线  MAX_VALUE

③类名：首字母大写+驼峰原则 Main

④方法名：首字母小写+驼峰原则 runRun()



**4、运算符**

①算术运算符：+，-，*，/，%，++，--

②赋值运算符：=

③关系运算符：>，<，>=，<=，==，!= ，instanceof

④逻辑运算符：&&，||，！（**短路运算**）

⑤位运算符：&（与），|（或），^（异或），~（非），>>（ 相当于/2），<<（相当于*2），>>>

\>>：带符号右移。正数右移高位补0，负数右移高位补1

\>>>：无符号右移。无论是正数还是负数，高位通通补0

⑥条件运算符：？:

⑦扩展赋值运算符：+=，-=，*=，、=

注意: +有时候表示字符串的拼接，a=10,b=20,  则""+a+b ->  1020 ， 而a+b+"" -> 30



**5、包机制**

![](./面试总结.assets/包机制.png)



**6、JavaDoc**

@author作者名		@version版本号		@since指明最早使用的jdk版本

@param参数名		@return返回值情况		@throws异常抛出情况

生存JavaDoc的命令：javadoc -encoding UTF-8 -charset UTF-8 test.java



7、Scanner类输入

```java
Scanner sc = new Scanner(System.in);
if (sc.hasNext()) {
	String str = sc.next();
}
```

![](.\面试总结.assets\next和nextline.png)

**8、关于流程控制的补充**

```java
switch(expression) {
    case A:
        语句;
       	break;
    default:
        语句;
}
```



switch语句中的变量类型: byte 、short、int、char

JavaSE7 中 switch支持字符串String类型，case必须位字符串常量或字面量



循环中的九九乘法表

![](.\面试总结.assets\九九乘法表.png)

**9、方法的重载**

重载：在一个类中有相同的函数名称，但是形参不同的函数

规则：方法名相同，参数列表不同（个数，类型，参数排列顺序），但是返回类型不同不足以成为方法的重载。



可变参数： void test(int...i) 必须是参数的最后一个



**10、内存分析**

![image-20220221205808806](.\面试总结.assets\内存分析.png)

**11、数组的三种初始化：**

①静态初始化： int[] arr = {1, 2, 3};

②动态初始化：int[] arr = new int[3]; a[0] = 1

③数组默认初始化：数组是引用类型



Arrays工具类：

fill(nums, x)方法：nums数组填充x

toString()方法：打印数据元素

sort（）方法：数组排序

equals（）方法：比较数组中的元素值是否相等

查找数组元素：通过binarySearch（）方法堆排序好的数组进行二分查找



**12、值传递和引用传递**（实际是传递地址）

值传递：基础类型

引用传递：类、接口、数组



**13、构造器**

和类名相同，没有返回值 

new的本质是在调用构造器

定义了有参构造，如果使用无参构造，必须显示写出有参构造



**14、封装、继承、多态**

① 关于封装

高内聚，低耦合

属性私有private，通过get/set获取或设置

隐藏代码的实现细节，保证数据的安全性



② 关于继承

is a的关系

```java
public void test(String name) {
    System.out.println(name);
    System.out.println(this.name);
    System.out.println(super.name);
} 
```

super调用父类的构造方法，必须在构造方法中的第一个

super必须只能出现在子类的方法或构造方法中

super和this不能同时调用构造方法



super和this的区别

代表对象不同：

​		super表示父类对象的引用

​		this表示本身对象的调用

前提：

​		this 没有继承也可以使用

​		super 只能在继承条件中才可以使用

构造方法：

​		this（）本类的构造

​		super（）父类的构造



③ 关于多态

多态：父类的引用指向子类对象（方法的多态，不是属性的多态）

静态方法：方法的调用只和左边所定义的数据类型有关（类加载就出现）

非静态方法：先继承后重写 。编译看左（只能调用左边存在的方法），运行看右（有重写，执行重写的方法）



A extends B

A a = new A();

B a = new A(); // 多态

注意问题：

**1 父类可以指向子类，但是不能调用子类的方法**

**2 子类可以调用自己或者父类的方法**

**3 static 方法属于类，不属于实例， final 不能被修改， private方法**

④ 重写

注意点：

1 子类继承父类，子类重写父类方法，而且必须是方法名字相同,方法体不同

2 参数列表相同

3 修饰符和范围可以扩大： private -> public

4 抛出的异常范围可以缩小： Exception -> ClassNotFoundException



**15、instanceof方法**

判断一个对象是什么类型

instanceof （类型转换）



**16、关于代码的加载先后顺序**

```java
public class Demo {
    static {
        1 静态代码块（只执行一次）
    }
    {
        2 匿名代码块
    }
    public Demo() {
        3 构造方法代码块
    }
}
```

**17、抽象类和接口**

类单继承，接口可以多继承

抽象类：

1、子类继承，然后重写实现

2 、抽象类中可以写普通的方法，但是抽象方法必须在抽象类中



| 普通类 | 只有具体实现                                                 |
| ------ | ------------------------------------------------------------ |
| 抽象类 | 有具体实现和抽象方法                                         |
| 接口   | 只有抽象方法（属性是public static final和方法是public abstract） |

面向接口编程：约束和实现分离（能不能的问题）

**18、内部类**

① 成员内部类

```java
public class Outer {
    private int id = 10;
    public void out() {}
    
    public class Inner {
        public viod in() {}
        
        public void getID() {
            
        }
    }
}

psvm {
    Outer.Inner inner = new  Outer().new Inner();
}
```



② 局部内部类（方法内部定义）

```java
public class Outer {
    private int id = 10;
    public void out() {
        class Inner() {
            
        }
    }
}
```



③ 静态内部类

```java
public class Outer {
    private int id = 10;
    public void out() {}
    
    public static class Inner {
        public viod in() {}
        
        public void getID() {
            
        }
    }
}
```



④ 匿名内部类

**接口的匿名实现类的匿名对象**

**抽象类的匿名子类的匿名对象**

new Fly() {

​	@Override

​	public void test() {}

};

**19、异常类（异常Exception和错误Error  ）**

Error通常是虚拟机抛出的异常，一般程序是无法控制和处理的，Exception一般是程序可以处理的异常



处理：try、catch、finally、throw、throws

catch（想要捕获的类型）

finally （释放资源）

throw new Exception(); （主动抛出异常，一般在方法中使用）

throws (如果方法不能处理异常，那么在方法上使用)

## 2-容器

## 3-并发编程

## 4-JVM

## 5-新特性

## 6-小技巧

## 7-JavaWeb

### 1 基本概念 

#### 1.1 静态web和动态web

- 静态web： 提供给所有人的数据始终不变
- 动态web：会动态变化，技术栈使用servlet/jsp

**1.2 web应用程序**

- 可以供浏览器访问的程序

- 统一的web资源会放在同一个文件夹下，web应用程序 -> tomcat 服务器

- 包含：html/css/js、jsp/servlet、java程序、jar包、配置文件（properties）

  ![image-20220223094157602](面试总结.assets/image-20220223094157602.png)

动态web的特点是：

1 可以与数据库进行数据交换（数据持久化） 

2 web页面动态更新 

3 资源发生错误，需要重新编写后台程序，重新发布



### 2  web服务器

tomcat（服务器处理用户的一些请求或给出响应）

jsp/ servlet（B/S架构）在服务器上的程序



### 3 Tomcat

#### 3.1 tomcat启动 

![image-20220223100216087](面试总结.assets/image-20220223100216087.png)cmd: catalina run

测试网站： localhost:8080

#### 3.2 tomcat配置

注意java环境变量配置 + 乱码问题-配置文件配置

![image-20220223101410502](面试总结.assets/image-20220223101410502.png)

![image-20220223101558515](面试总结.assets/image-20220223101558515.png)

#### 3.3 面试题：网站是如何访问的

```java
1 输入一个域名，回车
2 检查本机的C:\Windows\System32\drivers\etc\hosts配置文件下有没有该域名
    1）有，直接返回对应的ip地址，如localhost: 127.0.0.1
    2）没有,去远程dns服务器寻找，找到返回，否则不存在
```

#### 3.4发布一个web网站

放在tomcat指定的web应用文件夹（webapps）中

```java
网站的结构：
-webapps: tomcat服务器的web目录
    -ROOT
    -projectName: 项目目录名
        -WEB-INF
        	-classes: Java程序
            -lib: web应用所依赖的jar包
            -web.xml: 网站配置文件
        -index.html
        -static
            -css
            -js
            -img
```

**3.5 idea中配置tomcat**

![image-20220223175102167](面试总结.assets/image-20220223175102167.png)

![image-20220223175010744](面试总结.assets/image-20220223175010744.png)

![image-20220223175233336](面试总结.assets/image-20220223175233336.png)

![image-20220223190501550](面试总结.assets/image-20220223190501550.png)

**3.6 关于添加Artifact中war和war exploded的区别**

① war 模式：这种可以称之为是发布模式，看名字也知道，这是先打成war包，再发布；

② war exploded 热部署
  刚开始使用idea，发现工程每次修改JS或者是JSP页面后，并没有生效，每次修改都需要重启一次Tomcat才能体现刚刚所作的修改，这种方式浪费了自己很多时间，那么通过war exploded模式可以实现热部署，即每次修改代码后，不用重新启动tomcat即可实时显示自己代码修改后的效果。

③ 热部署方式相关设置
tomcat配置
		1）on ‘update‘ action：当用户主动执行更新的时候更新　　　　
  2）on frame deactication: 在编辑窗口失去焦点的时候更新
  3）你可以根据自己的需求进行设置，我这里两个都有设置，都设置成 Update classes and resources



servlet修改之后不更新的原因

F12打开开发者工具，选到network一栏，找到Disable cache 打钩，刷新就不会读缓存。

![image-20220223213420736](面试总结.assets/image-20220223213420736.png)

开启idea自动build功能（热部署）+ restart  tomcat服务器

![img](面试总结.assets/70.png)

**4 Http**

**4.1 http概念**

hhtp是超文本传输协议

​	http: 80端口

​	https:423端口

**4.2 http的两个时间**

​	HTTP/1.0: c和s连接一次只能获得一个web资源，断开连接

​	HTTP/2.0: c和s连接后，可以获得多个web资源

**4.3 Http请求**

```java
Request URL: https://www.baidu.com/ 请求地址 
Request Method: GET    get/post方法
Status Code: 200 OK	   状态码 200
Remote Address: 14.215.177.38:443
```

```java
Accept:text/html
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cache-Control: max-age=0
Connection: keep-alive
```

**请求行**

- 请求行中的请求方式：get

- 请求方式：get/post、head、delete、put、tract

  	- get：请求能携带的参数少，大小有限制，会在浏览器的url地址栏中显示数据，不安全，但高效
  	- post：请求能够携带的参数多，大小没有限制，不会再浏览器的url地址栏中显示数据，安全，但不高效


**消息头**

```java
Accept:text/html 	告诉浏览器，它所支持的数据类型
Accept-Encoding: 支持的编码 gbk utf-8  gb2312 iso8559-1
Accept-Language: zh-CN,zh;q=0.9	语言环境
Cache-Control: max-age=0	
Connection: keep-alive	请求完是断开还是连接
host		主机
```

**4.4 Http响应**

```java
Cache-Control: private
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
```

**响应体**

```java
Accept:text/html 	告诉浏览器，它所支持的数据类型
Accept-Encoding: 支持的编码 gbk utf-8  gb2312 iso8559-1
Accept-Language: zh-CN,zh;q=0.9	语言环境
Cache-Control: max-age=0	
Connection: keep-alive	请求完是断开还是连接
host		主机
refresh: 告诉客户端，多久刷新一次
location: 让网页定位
```



**响应状态码**

200	请求响应成功

404	找不到资源

3**	请求重定向

500	服务器代码错误

502	网关错误

常见面试题：当地址栏输入地址并回车到页面显示经历了什么？



**5 Maven**

maven自动导入和配置jar包的工具

**5.1 Maven项目架构管理工具（方便导入jar包）**

核心思想：约定大于配置

**5.2 下载安装和配置maven**

1 环境变量配置

- M2_HOME   maven目录下的bin目录

- MAVEN_HOME  maven的目录
- 在系统的path中配置 %MAVEN_HOME%\bin
- win10系统，环境变量显示长条而不是列表形式
  修改环境变量，第一个不要使用%%这种路径，保存后重新打开，就会发现以列表形式显示了
- mvn -v   命令查看是否安装成功



![image-20220223162105015](面试总结.assets/image-20220223162105015.png)

​	

![image-20220223162156967](面试总结.assets/image-20220223162156967.png)

2 中央仓库配置

![image-20220223161725991](面试总结.assets/image-20220223161725991.png)

**5.3 阿里云镜像**

```xml
// 配置阿里云防止被墙
<mirrors>
    <mirror>  
	    <id>alimaven</id>  
      <name>aliyun maven</name>  
      <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
      <mirrorOf>*,!jeecg,!jeecg-snapshots</mirrorOf> 
     //如果不加，默认所有的依赖都会去阿里云仓库下载，加上后jeecg的依赖包就可以从jeecg私服下载了。
     // <mirrorOf>central</mirrorOf>        
    </mirror>	
	
    <mirror>
      <id>repo2</id>
      <name>repo2 maven</name>
      <url>http://repo2.maven.org/maven2/</url>
	    <mirrorOf>central</mirrorOf>
    </mirror>
 </mirrors>
```

**5.4 idea配置maven**

1 创建maven web项目

![image-20220223172239063](面试总结.assets/image-20220223172239063.png)

![image-20220223172430236](面试总结.assets/image-20220223172430236.png)

![image-20220223172441655](面试总结.assets/image-20220223172441655.png)

2 等待项目初始化完毕

![image-20220223173042817](面试总结.assets/image-20220223173042817.png)

![image-20220223173050513](面试总结.assets/image-20220223173050513.png)



3 idea中的maven设置

![image-20220223173524279](面试总结.assets/image-20220223173524279.png)

![image-20220223173633014](面试总结.assets/image-20220223173633014.png)

4 创建普通maven项目

什么都不用选

![image-20220223174032832](面试总结.assets/image-20220223174032832.png)

![image-20220223174124692](面试总结.assets/image-20220223174124692.png)

**5.5 标记文件夹的功能**

方式一：

![image-20220223174459769](面试总结.assets/image-20220223174459769.png)

![image-20220223174355076](面试总结.assets/image-20220223174355076.png)

方式二：

![image-20220223174619149](面试总结.assets/image-20220223174619149.png)

**5.6 pom文件** 

pom.xml是maven的核心配置文件

![image-20220223191431857](面试总结.assets/image-20220223191431857.png)

![image-20220223191541521](面试总结.assets/image-20220223191541521.png)

![image-20220223191646459](面试总结.assets/image-20220223191646459.png)

**5.7 Maven资源导出问题**

（maven由于他的约定大于配置，我们之后可能会遇到写的配置文件无法被导出或者生效的问题，解决方案如下）

**在build中配置resources节点，防止资源导出失败的问题**

```xml
<build>
    .......
      <resources>
        <resource>
            <directory>src/main/resources</directory>
            <excludes>
                <exclude>**/*.properties</exclude>
                <exclude>**/*.xml</exclude>
             </excludes>
            <filtering>false</filtering>
        </resource>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>false</filtering>
        </resource>
    </resources>
    ......
</build>
```



![image-20220223191949954](面试总结.assets/image-20220223191949954.png)

**5.8 idea生成jar包关系树**

![image-20220223192704745](面试总结.assets/image-20220223192704745.png)

![image-20220223192717614](面试总结.assets/image-20220223192717614.png)

**5.9 maven遇到的问题**

1 maven 3.6.2 出现unable to import maven project see logs for details

​	降级maven的版本

2 tomcat闪退

3 idea每次都要重新配置maven

全局设置maven的xml配置和本地的仓库

![image-20220223194034418](面试总结.assets/image-20220223194034418.png)

4 maven项目中tomcat无法配置

5 maven默认的web项目的web.xml的版本问题

在webapp目录下的web.xml改为使用tomcat的ROOT目录下的web.xml的4.0版本最为和tomcat兼容

6 maven仓库的使用

https://mvnrepository.com/

![image-20220223202449842](面试总结.assets/image-20220223202449842.png)

![image-20220223202717013](面试总结.assets/image-20220223202717013.png)

找到多人用的，然然后删除作用域，在pom.xml中添加依赖

![image-20220223202655008](面试总结.assets/image-20220223202655008.png)

7 idea自动导入maven

手动设置，File → Settings → Importing → Import [Maven](https://so.csdn.net/so/search?q=Maven&spm=1001.2101.3001.7020) projects automatically → OK。 



**6 Servlet**

**6.1 Servlet介绍**

动态web技术，开发Servlet程序，先实现servlet接口，然后把该类部署在web服务器中

把实现了servlet接口的java程序叫做servlet

**6.2 helloServlet**

1 构建一个普通maven项目，删除src，然后在空的工程放新的module

2 关于maven父子工程的理解

父项目

```xml
<modules>
    <module>servlet-01</module>
</modules>
```

子项目

```xml
<parent>
    <artifactId>javaweb-02-servlet</artifactId>
    <groupId>com.ljw</groupId>
    <version>1.0-SNAPSHOT</version>
</parent>
```

3 maven环境的优化 

① 把子项目的webapp中的web.xml更新（tomcat中ROOT中的）

② 将maven的结构搭建完整： 添加java目录和resources目录

4 编写一个servlet

​	① 编写一个普通类

​	② 实现servlet接口，这里继承httpservlet

​			重写doGet和doPost方法

5 在webapp文件夹中web.xml编写servlet的映射

浏览器访问web服务器，需要在web服务器中注册servlet,和浏览器能够访问的路径

```xml
<!--注册servlet程序-->
<servlet>
    <servlet-name>helloServlet</servlet-name>
    <servlet-class>com.ljw.servlet.HelloServlet</servlet-class>
</servlet>
<!--servlet程序映射-->
<servlet-mapping>
    <servlet-name>helloServlet</servlet-name>
    <url-pattern>/helloServlet</url-pattern>
</servlet-mapping>
```

6 配置tomcat

![image-20220224172229617](面试总结.assets/image-20220224172229617.png)



![image-20220224172251747](面试总结.assets/image-20220224172251747.png)

**6.3 servlet的原理**

![image-20220224205120848](面试总结.assets/image-20220224205120848.png)

**6.4 Mapping问题**

① 一个servlet指定一个映射路径

```xml
<servlet-mapping>
    <servlet-name>helloServlet</servlet-name>
    <url-pattern>/helloServlet</url-pattern>
</servlet-mapping>
```

② 一个servlet可以指定多个映射路径

```xml
<servlet-mapping>
    <servlet-name>helloServlet</servlet-name>
    <url-pattern>/h1</url-pattern>
</servlet-mapping>
<servlet-mapping>
    <servlet-name>helloServlet</servlet-name>
    <url-pattern>/h2</url-pattern>
</servlet-mapping>
```

③ 一个servlet指定通用的映射路径

```xml
<servlet-mapping>
    <servlet-name>helloServlet</servlet-name>
    <url-pattern>/h1/*</url-pattern>
</servlet-mapping>
```

④ 一个servlet指定默认请求路径（一般不用）

没有了index，直接访问该servlet程序

```xml
<servlet-mapping>
    <servlet-name>helloServlet</servlet-name>
    <url-pattern>/*</url-pattern>
</servlet-mapping>
```

⑤ 自定义后缀实现请求映射

```xml
<servlet-mapping>
    <servlet-name>helloServlet</servlet-name>
    <url-pattern>*.do</url-pattern>
</servlet-mapping>
```

注意：指定的默认映射的优先级别最高，如果没有则是默认的

**6.5 servletContext对象**

![image-20220226193243736](面试总结.assets/image-20220226193243736.png)

web容器启动时，为每个web程序创建一个对应的servletContext对象，每一个对应一个web应用

- **1 共享数据：servlet之间共享数据**

  ```java
  // servlet上下文 防止数据  a.servlet
  ServletContext context = this.getServletContext(); 
  String username = "abc";
  context.setAttribute("username", username);
  
  // b.servlet
  ServletContext context = this.getServletContext();
  String username = (String) context.getAttribute("username");
  
  resp.setContentType("text/html");
  resp.setCharacterEncoding("utf-8");
  resp.getWriter().println("username: " + username);
  ```

- **2 获取初始化数据**

  ```java
  // 获得初始化参数 a.servlet
  String url = context.getInitParameter("url");
  
  // xml
  <!--配置一些web应用的参数-->
  <context-param>
       <param-name>url</param-name>
       <param-value>jdbc:mysql://localhost:3306/mybatis</param-value>
  </context-param>
      
  ```

- **3 请求转发**

  请求转发：地址不变

  ![image-20220226203920799](面试总结.assets/image-20220226203920799.png)

  重定向：地址发生变化

  ![image-20220226203957699](面试总结.assets/image-20220226203957699.png)

  ```java
  ServletContext context = this.getServletContext();
     context.getRequestDispatcher("/helloServlet").forward(req, resp);
  ```

- **4  读取资源文件**

  properties

  - 在java目录下新建properties

  - 在resources目录下新建properties

    发现：都被打包在同一路径下：classes，即俗称的classpath

  注意问题：maven资源导出问题

  ![image-20220226204831368](面试总结.assets/image-20220226204831368.png)

  在maven clean 和install之后，target中java包中的资源没有生成导出

  ![image-20220226204918964](面试总结.assets/image-20220226204918964.png)

  解决方法：

  ```xml
  // web.xml
  <build>
        <resources>
          <resource>
              <directory>src/main/resources</directory>
              <excludes>
                  <exclude>**/*.properties</exclude>
                  <exclude>**/*.xml</exclude>
               </excludes>
              <filtering>false</filtering>
          </resource>
          <resource>
              <directory>src/main/java</directory>
              <includes>
                  <include>**/*.properties</include>
                  <include>**/*.xml</include>
              </includes>
              <filtering>false</filtering>
          </resource>
      </resources>
  </build>
  ```

  获取资源：创建文件流

  ```java
  InputStream is = this.getServletContext().getResourceAsStream("/WEB-INF/classes/db.properties");
  Properties pros = new Properties();
  pros.load(is);
  
  String username = pros.getProperty("username");
  String password = pros.getProperty("password");
  
  resp.getWriter().println(username + " " + password);
  ```

  

- **2 获取初始化数据**

- **2 获取初始化数据**


## 8-Spring

## 9-SpringMVC

## 10-Mybatis

## 11-SpringBoot



# 计算机基础

## 1-计算机网络

### 概述

**网络的网络**

网络把主机连接起来，互联网把多种不同的网络连接起来，即互联网是网络的网络。

**ISP**

*Internet Service Provider*，互联网服务提供商，ISP分为第一层ISP,区域ISP和接入ISP。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72be01cd-41ae-45f7-99b9-a8d284e44dd4.png)

**主机之间的通信方式**

客户-服务器（C/S）:客户是服务的请求方，服务器是服务的提供方

对等（P2P）：不区分客户和服务器

**电路交换与分组交换**

电路交换：电路交换用于电话通信系统，两个用户通信前先建立一条专用的物理链路，并且在整个通信过程中始终占有该链路，但是电路交换对线路的利用率很低。

分组交换：每个分组都含有首部和尾部，包含源地址和目的地址，在同一传输线路中可以同时传输多个分组

**（分组交换+存储转发）**

**时延**

总时延 = 传输时延 + 传播时延 + 排队时延 + 处理时延

① 排队时延

分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。

② 处理时延

主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。

③ 传输时延

主机或路由器传输数据帧所需要的时间。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dcdbb96c-9077-4121-aeb8-743e54ac02a4.png)



其中 l 表示数据帧的长度，v 表示传输速率。

④传播时延

电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a1616dac-0e12-40b2-827d-9e3f7f0b940d.png)



其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4b2ae78c-e254-44df-9e37-578e2f2bef52.jpg)

**计算机网络体系结构**

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png)

**① OSI七层模型**：

表示层：数据压缩、加密和数据描述，使得应用程序不必关系再各台主机中数据格式不同的问题。

会话层：建立以及管理会话。

**② 五层协议：**

应用层：为特定的程序提供数据传输服务，如HTTP、DNS等协议。**数据单位是报文。**

运输层：为进程提供数据传输服务（面向端口）。

TCP（传输控制协议），**数据单位是报文段**，面向有连接，可靠的数据传输服务，主要提供完整性服务；

UDP（用户数据报协议），**数据单位是用户数据报**，面向无连接，尽最大努力的数据传输服务，主要提供及时性服务。

网络层：为主机提供数据传输服务。但是传输层的协议是为主机中的进程提供数据传输服务。网络层把传输层的报文段或者用户数据报封装成分组。**数据单位是分组**，分组交换和存储转发。

数据链路层：主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。**数据单位是帧。**

物理层：如何再传输媒介上透明地传输比特流。**数据单位是比特流。**

**③ TCP/IP：**应用层、运输层、网际层、网络接口层

相当于五层协议中的数据链路层和物理层合并成为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png)

**④ 数据在各层之间的传输过程：**

向下过程中，需要添加下层协议所需要的首部或者尾部，向上的过程中，需要拆开首部和尾部。



路由器只有下三层协议，网络层，数据链路层和物理层，不需要为进程或者应用程序提供服务，所以不需要传输层和应用层。



### 物理层

**1 通信方式**

- 单工通信： 单向传输
- 半双工通信:  双向交替传输
- 全双工同信： 双向同时传输

**2 带通调制**

**模拟信号是连续信号，数字信号是离散信号。带通调制：把数字信号转换为模拟信号**

### 链路层

1 基本问题

- 封装成帧

  网络层的ip数据报添加首部和尾部，标记帧的开始和结束

- 透明传输

  通过增加转义字符解决帧开始和结束或则和信息体出现转义字符的问题

- 差错检测

  CRC循环冗余检验检测比特差错

2 信道分类

- 广播信道（一对多）

  一个节点发送数据能被广播信道上所有的节点接收

  在广播信道上传输数据需控制方法进行协调：① 信道复用技术 ② CSMA/CD协议

- 点对点信道（一对一）

  ppp协议进行控制

3 信道复用技术

- **频分复用**（频率）

- 时分复用（时分复用帧）

- **统计时分复用**（不固定每个用户在时分复用帧中的位置，**只要有数据就集中起**来组成统计时分复用帧**然后发送**）

- **波分复用**（光频率很高，一般使用光波长）

- **码分复用**（任意两个码片正交）

  发送方码片：00011011

  发送1时发送码片，发送0时发送码片反码

  接受方使用码片对接受的数据进行内积，内积为1则为比特1，内积为-1则为比特0，内积为0则为不相关用户发的信息

4 CSMA/CD协议（载波监听多点接入 / 碰撞检测）

- **多点接入**：总线型网络，许多主机多点接入到总线上
- **载波监听**：先听后发，边听边发，碰撞停发，选择重发
- **碰撞检测**：发送中，监听到信道已有其他主机正在发送数据，表示发生碰撞。
- 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 **争用期** 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。
- 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 **截断二进制指数退避算法** 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。

![img](面试总结.assets/19d423e9-74f7-4c2b-9b97-55890e0d5193.png)

5 ppp协议

PPP 协议是**用户**计算机和 **ISP（因特网服务提供商）** 进行通信时所使用的数据链路层协议。

ppp帧信息部分长度不超过1500


6 MAC地址

MAC是数据链路层地址，6字节48位，用于唯一标识网络适配器（网卡）。

一台主机拥有多少个网络适配器就有多少个 MAC 地址。

7 局域网

8 以太网

9 交换机

10 虚拟局域网



### 网络层

### 传输层

### 应用层



## 2-操作系统



## 3-数据结构



## 4-算法



# 数据库



# 系统结构



# 分布式



# 高性能



# 高可用



# 简历模板

![image-20211217211039759](C:\Users\tesseract\AppData\Roaming\Typora\typora-user-images\image-20211217211039759.png)

